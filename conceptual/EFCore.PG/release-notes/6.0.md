# 6.0 Release Notes

The release candidate of Npgsql Entity Framework Core provider version 6.0 has been released and is available on nuget. This version works with [version 6.0 of Entity Framework Core](https://docs.microsoft.com/ef/core/what-is-new/ef-core-6.0/whatsnew), and brings new Npgsql features in addition to the general EF Core changes.

Npgsql 6.0 brings some major breaking changes and is not a simple in-place upgrade. Carefully read the breaking change notes below and upgrade with care.

## New features

### Timestamp rationalization and improvements

Support for `timestamp with time zone` and `timestamp without time zone` has been rationalized and simplified, and aligned with PostgreSQL best practices. In particular, the "UTC everywhere" pattern is much better supported via the PostgreSQL `timestamp with time zone` type, which is the recommended way to handle timestamps. A detailed explanation is available in [this blog post](https://www.roji.org/postgresql-dotnet-timestamp-mapping), below is a summary of the main improvements.

* UTC timestamps have been cleanly separated from non-UTC timestamps, aligning with the PostgreSQL types. The former are represented by `timestamp with time zone` and DateTime with Kind UTC, the latter by `timestamp without time zone` and DateTime with Kind Local or Unspecified. It is recommended to use UTC timestamps where possible.
* Npgsql no longer performs any implicit timezone conversions when reading or writing any timestamp value - the value in the database is what you get, and the machine timezone no longer plays any role when reading/writing values.
* Npgsql no longer supports date/time representations which cannot be fully round-tripped to the database. If it can't be fully stored as-is, you can't write it.
* A compatibility switch enables opting out of the new behavior, to maintain backwards compatibility.

This change introduces significant breaking changes (see below), although a compatibility flag can be used to opt out and revert to the previous behavior.

Other date/time improvements include:

* Support for the new [.NET DateOnly and TimeOnly types](https://devblogs.microsoft.com/dotnet/date-time-and-time-zone-enhancements-in-net-6/).
* Most [DateTimeOffset](https://docs.microsoft.com/dotnet/api/system.datetimeoffset) members and methods are now translated.
* Many NodaTime translations have been added for [ZonedDateTime](https://nodatime.org/3.0.x/api/NodaTime.ZonedDateTime.html), [Period](https://nodatime.org/3.0.x/api/NodaTime.Period.html), [DateInterval](https://nodatime.org/3.0.x/api/NodaTime.DateInterval.html) and others.
* PostgreSQL `daterange` is now mapped to NodaTime [DateInterval](https://nodatime.org/3.0.x/api/NodaTime.DateInterval.html), and most methods on it are translated ([#1998](https://github.com/npgsql/efcore.pg/issues/1998)).

### Other new features

* The provider is now fully annotated for nullable reference types.
* Support for the PostgreSQL [ltree](https://www.postgresql.org/docs/current/ltree.html) type, which represents labels of data stored in a hierarchical tree-like structure. Requires PostgreSQL 13 and above.
* Multiple spatial translations have been added for NetTopologySuite ([DistanceKnn, <->](https://github.com/npgsql/efcore.pg/issues/1827), [ST_Force2D](https://github.com/npgsql/efcore.pg/issues/1917), [ST_Distance and ST_DWithin with spheriod](https://github.com/npgsql/efcore.pg/issues/1638)).

The full list of issues for this release is [available here](https://github.com/npgsql/efcore.pg/milestone/34?closed=1).

## Breaking changes

### Major changes to timestamp mapping

> [!NOTE]
> It is possible to opt out of these changes to maintain backwards compatibility, see below.

#### Quick summary

* Most applications want to store UTC timestamps in the database. To do this, migrate your `timestamp without time zone` columns to `timestamp with time zone` ([see migration notes below](#migrating-columns-from-timestamp-to-timestamptz)), and always use DateTime with Kind=Utc when interacting with Npgsql.
* For the few cases where non-UTC timestamps are desired, add explicit configuration to your properties to be `timestamp without time zone`

#### Detailed notes

The below notes will use the PostgreSQL aliases `timestamptz` to refer to `timestamp with time zone`, and `timestamp` to refer to `timestamp without time zone`. Note that `timestamp with time zone` represents a UTC timestamp and does **not** store a timezone in the database.

* DateTime properties now map to `timestamptz` by default, instead of to `timestamp`; this follows the recommended practice of storing UTC timestamps by default, but will cause the first migration to change your column type.
  * If the intention is to store point-in-time or UTC timestamps, it's recommended to allow the migration to occur ([see migration notes below](#migrating-columns-from-timestamp-to-timestamptz)).
  * If the column really should store non-UTC timestamps (local or unspecified), [explicitly set the column type back to `timestamp`](https://docs.microsoft.com/ef/core/modeling/entity-properties#column-data-types). This is usually discouraged, but can be a temporary solution before transitioning to `timestamptz`.
* It is no longer possible to write DateTime with Kinds Local or Unspecified to `timestamptz` properties (which are the default for DateTime). Previously, Npgsql allowed writing those, performing timezone conversions from local to UTC. To write to `timestamptz`, provide a UTC DateTime. Similarly, it is no longer possible to write DateTime with Kind UTC to a `timestamp` column.
* `timestamptz` values are now read back as DateTime with Kind=UTC, without any conversions; these were previously returned as local DateTime, converted to the local machine's timezone. When reading `timestamptz` values as [DateTimeOffset](https://docs.microsoft.com/dotnet/api/system.datetimeoffset), UTC values (offset 0) are always returned.
* It is no longer possible to write [DateTimeOffset](https://docs.microsoft.com/dotnet/api/system.datetimeoffset) with offsets other than 0 (UTC), since these cannot be represented in PostgreSQL. These were previously implicitly converted to UTC before sending.

See the [Npgsql ADO.NET docs](/doc/release-notes/5.0.html) for additional lower-level changes to timestamp handling.

#### NodaTime changes

* Properties with type [Instant](https://nodatime.org/3.0.x/api/NodaTime.Instant.html) are now mapped to `timestamptz` columns, and not to `timestamp`, since they represent a universally agreed-upon point in time. This follows the recommended practice, but will cause the first migration to change your column type.
  * If the intention is to store point-in-time or UTC timestamps, it's recommended to allow the migration to occur ([see migration notes below](#migrating-columns-from-timestamp-to-timestamptz)).
  * If the column really should store non-UTC timestamps (local or unspecified), change the property's type to [LocalDateTime](https://nodatime.org/3.0.x/api/NodaTime.LocalDateTime.html) instead; this will maintain the mapping to `timestamp`. This is usually discouraged, but can be a temporary solution before transitioning to `timestamptz`.
* When reading `timestamptz` as [ZonedDateTime](https://nodatime.org/3.0.x/api/NodaTime.ZonedDateTime.html) or [OffsetDateTime](https://nodatime.org/3.0.x/api/NodaTime.OffsetDateTime.html), UTC values are always returned. Previously, local values based on the PostgreSQL `TimeZone` parameter were returned.

#### Migrating columns from timestamp to timestamptz

As a result of the above changes, the first migration created after upgrading to 6.0 will alter the columns for all DateTime and Instant properties from `timestamp` to `timestamptz`. If these columns are meant to store point-in-time or UTC timestamps (the recommended practice), then it's best to let this migration proceed; but care must be taken.

As a starting point, let's assume your existing `timestamp` column has the timestamp `2020-01-01 12:00:00`:

```sql
SELECT "CreatedOn", pg_typeof("CreatedOn") AS type FROM "Blogs";
```

Results in:

```output
      CreatedOn      |            type
---------------------+-----------------------------
 2020-01-01 12:00:00 | timestamp without time zone
```

The migration generated by version 6.0 will cause the following SQL to be generated:

```sql
ALTER TABLE "Blogs" ALTER COLUMN "CreatedOn" TYPE timestamp with time zone;
```

When converting the `timestamp without time zone` column to `timestamp with time zone`, PostgreSQL will assume that existing values are local timestamps, and will convert them to UTC based on the `TimeZone` parameter. Performing the above query will result in something like:

```output
        CreatedOn       |           type
------------------------+--------------------------
 2020-01-01 12:00:00+02 | timestamp with time zone
```

This means that your new `timestamptz` column now contains 10:00 UTC, which is probably not what you want: if the original values were in fact UTC values, you need them to be preserved as-is, changing only the column type. To do this, edit your migration and add the following to the top of your migration's Up and Down methods:

```c#
migrationBuilder.Sql("SET TimeZone='UTC'");
```

This will ensure that no time zone conversions will be applied when converting the columns:

```output
        CreatedOn       |           type
------------------------+--------------------------
 2020-01-01 14:00:00+02 | timestamp with time zone
```

#### Opting out of the new timestamp mapping logic

The changes described above are far-reaching, and may break applications in various ways. You can upgrade to version 6.0 but opt out of the new mapping by enabling the `Npgsql.EnableLegacyTimestampBehavior` [AppContext switch](https://docs.microsoft.com/en-us/dotnet/api/system.appcontext?view=net-5.0). To do this and revert to the legacy timestamp behavior, add the following at the start of your application, before any Npgsql or EF Core operations are invoked:

```c#
AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
```

### NodaTime: daterange is scaffolded as DateInterval by default

When using NodaTime, a PostgreSQL `daterange` column is scaffolded as a [DateInterval](https://nodatime.org/3.0.x/api/NodaTime.DateInterval.html) property instead of a `NpgsqlRange<LocalDateTime>` property ([#1998](https://github.com/npgsql/efcore.pg/issues/1998)).

### Value converters for array/list properties need to use a special new API

Previously, it was possible to configure value converters for array/list properties with the general EF Core API:

```c#
modelBuilder.Entity<SomeEntity>.Property(e => e.ValueConvertedArray)
    .HasConversion(w => w.Select(x => x.Value).ToArray(), v => v.Select(x => new IntWrapper(x)).ToArray());
```

This is no longer possible and will cause an exception to be thrown. Instead, use the new `HasPostgresArrayConversion` API, providing conversion lambdas for the array's *elements*:

```c#
modelBuilder.Entity<SomeEntity>.Property(e => e.ValueConvertedArray)
    .HasPostgresArrayConversion(w => w.Value, v => new IntWrapper(v));
```
